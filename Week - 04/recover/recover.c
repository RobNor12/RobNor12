#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>

int main(int argc, char *argv[]){
    // Accept a single command-line argument
    if (argc != 2){
        printf("Usage: ./recover FILE\n");
        
        return 1;
    }

    // Open the memory card
    FILE *card = fopen(argv[1], "r");
    // Error check 
    if (card == NULL){
        printf("Could not open file.\n");
        
        return 1;
    }

    // File pointer for the current output JPEG, initialized to NULL
    FILE *img = NULL;

    // Create a buffer for a block of data (using the specified uint8_t from stdint.h)
    uint8_t buffer[512];

    // Character array to hold the dynamic filename
    char filename[8]; 

    // Counter for sequential filenames
    int jpeg_count = 0;

    // While there's still data left to read from the memory card
    while (fread(buffer, 1, 512, card) == 512){
        // Check for New JPEG Signature (State 1)
        // Explicitly cast buffer elements to (int) during comparison
        if ((int)buffer[0] == 0xff && (int)buffer[1] == 0xd8 && (int)buffer[2] == 0xff && (buffer[3] & 0xf0) == 0xe0 ){
            
            // Close the old file (if one was open)
            if (img != NULL){        
                fclose(img);
            }

            // Generate the new filename 
            sprintf(filename, "%03i.jpg", jpeg_count);

            // Open the new file and update the img pointer
            img = fopen(filename, "w");
            
            if (img == NULL){
                fclose(card);
                
                return 1; // Handle file opening error
            }

            fwrite(buffer, 1, 512, img);
            // Increment the counter
            jpeg_count++;
        }

        // Check if we are currently writing a JPEG file (State 2)
        else if (img != NULL){
            // Write the current block to the open file
            fwrite(buffer, 1, 512, img);
        }
    }

    // --- Final Cleanup ---
    // Close the last JPEG output file, if one was ever opened
    if (img != NULL){
        fclose(img);
    }

    // Close the input file
    fclose(card);

    return 0;
}

/*
cs50/problems/2025/x/recover
    
:) recover.c exists.
Log
checking that recover.c exists...
    
:) recover.c compiles.
Log
running clang recover.c -o recover -std=c11 -ggdb -lm -lcs50...
:) handles lack of forensic image
Log
running ./recover...
checking that program exited with status 1...
    
:) recovers 000.jpg correctly
Log
running ./recover card.raw...
checking that program exited with status 0...
checking that 000.jpg exists...
hashing 000.jpg...
    
:) recovers middle images correctly
Log
running ./recover card.raw...
checking that program exited with status 0...
checking that 001.jpg exists...
hashing 001.jpg...
checking that 002.jpg exists...
hashing 002.jpg...
checking that 003.jpg exists...
hashing 003.jpg...
checking that 004.jpg exists...
hashing 004.jpg...
checking that 005.jpg exists...
hashing 005.jpg...
checking that 006.jpg exists...
hashing 006.jpg...
checking that 007.jpg exists...
hashing 007.jpg...
checking that 008.jpg exists...
hashing 008.jpg...
checking that 009.jpg exists...
hashing 009.jpg...
checking that 010.jpg exists...
hashing 010.jpg...
checking that 011.jpg exists...
hashing 011.jpg...
checking that 012.jpg exists...
hashing 012.jpg...
checking that 013.jpg exists...
hashing 013.jpg...
checking that 014.jpg exists...
hashing 014.jpg...
checking that 015.jpg exists...
hashing 015.jpg...
checking that 016.jpg exists...
hashing 016.jpg...
checking that 017.jpg exists...
hashing 017.jpg...
checking that 018.jpg exists...
hashing 018.jpg...
checking that 019.jpg exists...
hashing 019.jpg...
checking that 020.jpg exists...
hashing 020.jpg...
checking that 021.jpg exists...
hashing 021.jpg...
checking that 022.jpg exists...
hashing 022.jpg...
checking that 023.jpg exists...
hashing 023.jpg...
checking that 024.jpg exists...
hashing 024.jpg...
checking that 025.jpg exists...
hashing 025.jpg...
checking that 026.jpg exists...
hashing 026.jpg...
checking that 027.jpg exists...
hashing 027.jpg...
checking that 028.jpg exists...
hashing 028.jpg...
checking that 029.jpg exists...
hashing 029.jpg...
checking that 030.jpg exists...
hashing 030.jpg...
checking that 031.jpg exists...
hashing 031.jpg...
checking that 032.jpg exists...
hashing 032.jpg...
checking that 033.jpg exists...
hashing 033.jpg...
checking that 034.jpg exists...
hashing 034.jpg...
checking that 035.jpg exists...
hashing 035.jpg...
checking that 036.jpg exists...
hashing 036.jpg...
checking that 037.jpg exists...
hashing 037.jpg...
checking that 038.jpg exists...
hashing 038.jpg...
checking that 039.jpg exists...
hashing 039.jpg...
checking that 040.jpg exists...
hashing 040.jpg...
checking that 041.jpg exists...
hashing 041.jpg...
checking that 042.jpg exists...
hashing 042.jpg...
checking that 043.jpg exists...
hashing 043.jpg...
checking that 044.jpg exists...
hashing 044.jpg...
checking that 045.jpg exists...
hashing 045.jpg...
checking that 046.jpg exists...
hashing 046.jpg...
checking that 047.jpg exists...
hashing 047.jpg...
checking that 048.jpg exists...
hashing 048.jpg...
    
:) recovers 049.jpg correctly
Log
running ./recover card.raw...
checking that program exited with status 0...
checking that 049.jpg exists...
hashing 049.jpg...
    
:) program is free of memory errors
Log
running valgrind --show-leak-kinds=all --xml=yes --xml-file=/tmp/tmpiyradz93 -- ./recover card.raw...
checking for valgrind errors...
*/
